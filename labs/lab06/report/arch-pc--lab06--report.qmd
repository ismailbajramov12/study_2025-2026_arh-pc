---
## Author
author:
  name: Байрамов Исмаил Мухандис оглы
  email: 1032253514@pfur.ru

## Title
title: "Отчёта по лабораторной работе №6. Арифметические операции в NASM."
number-sections: true
license: "CC BY"
---

# Цель работы

Освоение арифметических инструкций языка ассемблера NASM.

# Теоретическое введение

## Адресация в NASM

Большинство инструкций на языке ассемблера работают с операндами, расположенными либо в регистрах, либо в памяти. Способ, которым задаётся место хранения данных, называется *адресацией*. В NASM существуют три основных вида адресации:

1. **Регистровая адресация**
   Операнд находится в одном из регистров, и команда использует имя регистра.
   Пример:

   ```
   mov ax, bx
   ```

2. **Непосредственная адресация**
   В команде указывается непосредственное значение — число, известное в момент компиляции.
   Пример:

   ```
   mov ax, 2
   ```

3. **Адресация памяти**
   Операндом является адрес ячейки памяти. В команде используются символические имена переменных.
   Пример:

   ```
   intg dd 3       ; переменная в памяти
   mov eax, [intg] ; загрузить значение в EAX
   mov [intg], eax ; сохранить из регистра в память
   mov eax, intg   ; записать в EAX сам адрес переменной
   ```

Адрес переменной в этом случае заменяется компилятором конкретным числом, соответствующим расположению переменной в памяти.

---

## Арифметические операции в NASM

В NASM существует несколько арифметических инструкций, позволяющих выполнять операции над целыми числами.

### Инструкция add — сложение

Осуществляет целочисленное сложение двух операндов и записывает результат в первый операнд.

```
add операнд1, операнд2
```

Примеры:

```
add ax, 5      ; AX = AX + 5
add dx, cx     ; DX = DX + CX
```

Операнды должны иметь одинаковый размер.

---

### Инструкция sub — вычитание

Работает аналогично `add`, но выполняет вычитание:

```
sub операнд1, операнд2
```

Пример:

```
sub ebx, 5     ; EBX = EBX − 5
```

---

### Команды inc и dec — инкремент и декремент

Используются для увеличения или уменьшения значения на 1.
Имеют один операнд — регистр или ячейка памяти.

```
inc операнд
dec операнд
```

Эти инструкции короче, чем соответствующие `add операнд,1` или `sub операнд,1`.

---

### Команда neg — изменение знака

Инвертирует знак значения операнда (для чисел со знаком):

```
neg операнд
```

Пример:

```
mov ax, 1
neg ax      ; AX = −1
```

---

### Умножение: mul и imul

В NASM существуют разные инструкции для знакового и беззнакового умножения:

* **mul** — умножение без знака
* **imul** — умножение со знаком

В этих командах явно указывается **только один** операнд, который может быть регистром или памятью.
Второй множитель должен находиться в одном из регистров:

| Размер операнда | Неявный множитель | Результат |
| --------------- | ----------------- | --------- |
| 1 байт          | AL                | AX        |
| 2 байта         | AX                | DX:AX     |
| 4 байта         | EAX               | EDX:EAX   |

Пример:

```
a dw 270

mov ax, 100
mul a          ; DX:AX = AX * a
```

---

### Деление: div и idiv

Для деления также существуют две команды:

* **div** — беззнаковое деление
* **idiv** — знаковое деление

Указывается только делитель. Делимое размещается в строго определённых регистрах:

| Размер делителя | Делимое | Частное | Остаток |
| --------------- | ------- | ------- | ------- |
| 1 байт          | AX      | AL      | AH      |
| 2 байта         | DX:AX   | AX      | DX      |
| 4 байта         | EDX:EAX | EAX     | EDX     |

Пример:

```
mov ax, 31
mov dl, 15
div dl      ; AL=2, AH=1
```

---

## Преобразование чисел и символов: ASCII

Ввод и вывод данных из программ NASM выполняется в виде ASCII-символов.
Однако арифметические операции требуют числовых значений. Поэтому необходимо конвертировать:

* символы → числа
* числа → символы для вывода

Для лабораторных работ эти преобразования выполняют подпрограммы в файле **in_out.asm**:

* **iprint** — вывод целого числа
* **iprintLF** — вывод числа + перевод строки
* **atoi** — перевод ASCII-кода цифры в число

Использование:

```
mov eax, '6'
call atoi    ; теперь EAX содержит число 6

mov eax, 125
call iprintLF ; вывод числа на экран
```

Эти функции позволяют корректно работать с пользователем при вводе/выводе чисел.

---

# Выполнение лабораторной работы

1. Создадим каталог для программам лабораторной работы № 6, перейдем в него и создадим файл `lab6-1.asm` (рис. @fig-001).

![Терминал](image/1.png){#fig-001 width=70%}

2. Рассмотрим примеры программ вывода символьных и численных значений. Программы будут выводить значения записанные в регистр eax. Создадим файл `lab6-1.asm` (рис. @fig-002) и запустим его (рис. @fig-003). 

![Окно Midnight Commander. Редактирование файла](image/2.1.png){#fig-002 width=70%}

![Терминал](image/2.2.png){#fig-003 width=70%}

3. Далее изменим текст программы и вместо символов, запишем в регистры числа. Исправим текст программы (Листинг 6.1). Создадим исполняемый файл (рис. @fig-004) и запустим его (рис. @fig-005).

![Окно Midnight Commander. Редактирование файла](image/3.1.png){#fig-004 width=70%}

![Терминал](image/3.2.png){#fig-005 width=70%}

Ответ: Код 10 в ASCII — это управляющий символ LF (Line Feed, перевод строки, `\n`). При выводе на экран сам символ не отображается, вместо него просто происходит переход на новую строку (то есть пустая строка (или перенос) ).

4. Создадим файл `lab6-2.asm` в каталоге `~/work/arch-pc/lab06` и введем в него текст программы из листинга 6.2 (рис. @fig-006).

![Терминал](image/4.png){#fig-006 width=70%}

5. Аналогично предыдущему примеру изменим символы на числа. Создадим исполняемый файл и запустим его. Также заменим функцию iprintLF на iprint (рис. @fig-007).

![Терминал](image/5.png){#fig-007 width=70%}

Ответ: iprint — выводит число в десятичном виде без перевода строки. iprintLF — делает то же самое, но добавляет перевод строки после числа (как iprint, а потом ещё `\n`).

6. Введем текст программы из листинга 6.3, сохраним изменения и запустим исполняемый файл (рис. @fig-008).

![Терминал](image/6.1.png){#fig-008 width=70%}

![Терминал](image/6.2.png){#fig-009 width=70%}

7. Введем текст программы из листинга 6.4, сохраним изменения и запустим исполняемый файл (рис. @fig-010).

![Терминал](image/7.png){#fig-010 width=70%}

Ответы на вопросы:

**1.** Строки:

```asm
mov eax,rem
call sprint
```

**2.** Эти инструкции задают адрес буфера `x` в `ecx`, задают максимальное количество вводимых символов (80) в `edx` и вызывают подпрограмму `sread`, которая считывает строку с клавиатуры и помещает её в буфер `x`.

В программе это используется для ввода номера студенческого билета с клавиатуры в буфер `x`.

**3.**  Вызывает подпрограмму `atoi` из `in_out.asm`, которая переводит введённый с клавиатуры номер студенческого билета из строкового вида в число.

**4.** Строки:

```asm
xor edx,edx
mov ebx,20
div ebx
inc edx
```

**5.** Остаток от деления попадает в регистр `EDX`.

**6.** Увеличивает значение в `edx` на 1.

**7.** За вывод числового результата варианта отвечают строки:

```asm
mov eax,edx
call iprintLF
```

---

# Выполнение самостоятельной работы

Была написана программа вычисления выражения f(x) согласно варианту из таблицы (для моего номера 15 это функция y=(5+x)2−3). Программа запрашивает значение x, вычисляет y=(5+x)2−3 и выводит результат (см. рис. @fig-011)

![Окно Midnight Commander](image/s1.2.png){#fig-012 width=70%}

![Терминал](image/s1.1.png){#fig-011 width=70%}

# Выводы

В ходе лабораторной работы были изучены способы адресации в NASM, арифметические инструкции, ввод/вывод символов и чисел, а также работа с подпрограммами преобразования ASCII. Полученные навыки позволяют выполнять вычисления и организовывать взаимодействие программы с пользователем.

